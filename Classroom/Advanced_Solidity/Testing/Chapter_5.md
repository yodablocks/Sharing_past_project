# Chapter 5: The First Test- Creating a New Fish


## 2. Act

We've reached the part where we're going to be calling the function that creates a new fish for Alice-Â `createRandomFish`.

But there's a slight problem- how can we make it so the method "knows" who calls it? Another way to put it would be- how can we make sure Alice (and not Bob) is going to be the owner of this new fish?ğŸ§

Well... the problem is solved with theÂ _contract abstraction_. One of the features ofÂ _Truffle_Â is that it wraps the originalÂ _Solidity_Â implementation and lets us specify the address that makes the function call by passing that address as an argument.

The following callsÂ `createRandomFish`Â and makes sureÂ `msg.sender`Â is set to Alice's address:

```
const result = await contractInstance.createRandomFish(fishNames[0], {from: alice});
```

Now I have a quick question for you: do you know what gets stored inÂ `result`?

Well, let me explain.

#### Logs and Events

Once we specified the contract we wanted to test usingÂ `artifacts.require`,Â _Truffle_Â automatically provides the logs generated by our smart contract. What this means is that we can now retrieve theÂ `name`Â of Alice's newly created fish using something like this:Â `result.logs[0].args.name`. In a similar fashion, we can get theÂ `id`Â and theÂ `_dna`.

Besides these bits of information,Â `result`Â is going to be giving us several other useful details about the transaction:

- `result.tx`: the transaction hash
- `result.receipt`: an object containing the transaction receipt. IfÂ `result.receipt.status`Â is equal toÂ `true`Â it means that the transaction was successful. Otherwise, it means that the transaction failed.

> Note: Note that logs can also be used as a much cheaper option to store data. The downside is that they can't be accessed from within the smart contract itself.

## 3. Assert

In this chapter we will be using the built-in assertion module which comes with a set of assertion functions such asÂ `equal()`Â andÂ `deepEqual()`. Simply put, these functions check the condition andÂ `throw`Â an error if the result is not as expected. Since we will be comparing simple values, we are going to be runningÂ `assert.equal()`.

# Put it to the test

Let's finish off our first test.

1. Declare aÂ `const`Â namedÂ `result`, and set it equal to the result ofÂ `contractInstance.createRandomFish`Â with the fish's name and the owner as arguments.
    
2. Once we have theÂ `result`, callÂ `assert.equal`Â with two arguments-Â `result.receipt.status`Â andÂ `true`.
    

If the above condition is true, we can assume that our test has been passed. Just to be safe, let's add in one more check while we're here.

3. In the next line, check ifÂ `result.logs[0].args.name`Â equals toÂ `fishNames[0]`. UseÂ `assert.equal`, just like we did above.

Now, it is time to runÂ `truffle test`Â and see if our first test passes. The way this works is thatÂ _Truffle_Â will just inspect theÂ _"test"_Â directory and execute the files it finds there.

Actually, we've gone ahead and did that for you. The output should look something like this:

```
Contract: CryptoFish
    âœ“ should be able to create a new fish (323ms)


  1 passing (768ms)
```

This concludes your very first test - well done! There are several more to come, so let's get going on the next lesson...
